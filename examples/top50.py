from datetime import datetime
from pyaskit import define
import pyaskit.types as t

def log(index, recompilation_count):
    print(f'{index}: {recompilation_count}')

reverseString = define(t.str, 'Reverse the string {{s}}.')
compiledReverseString = reverseString.compile([{ "input": { "s": 'abc' }, "output": 'cba' }])
log(0, reverseString.recompilation_count)
factorial = define(t.int, 'Calculate the factorial of {{n}}.')
compiledFactorial = factorial.compile([{ "input": { "n": 5 }, "output": 120 }])
log(1, factorial.recompilation_count)
concatStrings = define(t.str, 'Concatenate the strings {{ss}}.')
compiledConcatStrings = concatStrings.compile([{ "input": { "ss": ['a', 'b', 'c'] }, "output": 'abc' }])
log(2, concatStrings.recompilation_count)
sortNumbers = define(t.list(t.int), 'Sort the numbers {{ns}} in ascending order.')
compiledSortNumbers = sortNumbers.compile([{ "input": { "ns": [3, 2, 1] }, "output": [1, 2, 3] }])
log(3, sortNumbers.recompilation_count)
findLargestNumber = define(t.int, 'Find the largest number in {{ns}}.')
compiledFindLargestNumber = findLargestNumber.compile([{ "input": { "ns": [1, 2, 3] }, "output": 3 }])
log(4, findLargestNumber.recompilation_count)
isPalindrome = define(t.bool, 'Check if {{n}} is a palindrome.')
compiledIsPalindrome = isPalindrome.compile([{ "input": { "n": 12321 }, "output": True }])
log(5, isPalindrome.recompilation_count)
sumNumbers = define(t.int, 'Calculate the sum of all numbers in {{ns}}.')
compiledSumNumbers = sumNumbers.compile([{ "input": { "ns": [1, 2, 3] }, "output": 6 }])
log(6, sumNumbers.recompilation_count)
averageNumbers = define(t.int, 'Calculate the average of all numbers in {{ns}}.')
compiledAverageNumbers = averageNumbers.compile([{ "input": { "ns": [1, 2, 3] }, "output": 2 }])
log(7, averageNumbers.recompilation_count)
countOccurrences = define(t.int, 'Count the number of occurrences of {{x}} in {{xs}}.')
compiledCountOccurrences = countOccurrences.compile([{ "input": { "xs": [1, 2, 3, 1, 2, 3], "x": 1 }, "output": 2 }])
log(8, countOccurrences.recompilation_count)
removeInstances = define(t.list(t.int), 'Remove all instances of {{x}} from {{xs}}.')
compiledRemoveInstances = removeInstances.compile([{ "input": { "xs": [1, 2, 3, 1, 2, 3], "x": 1 }, "output": [2, 3, 2, 3] }])
log(9, removeInstances.recompilation_count)
uniqueElements = define(t.list(t.int), 'Return the unique elements in {{xs}}.')
#compiledUniqueElements = uniqueElements.compile([{ "input": { "xs": [1, 2, 3, 1, 2, 3] }, "output": [1, 2, 3] }])
log(10, 10)
findFactorial = define(t.int, 'Find the factorial of {{n}}.')
compiledFindFactorial = findFactorial.compile([{ "input": { "n": 5 }, "output": 120 }])
log(11, findFactorial.recompilation_count)
isPrime = define(t.bool, 'Check if {{n}} is a prime number.')
compiledIsPrime = isPrime.compile([{ "input": { "n": 5 }, "output": True }])
log(12, isPrime.recompilation_count)
generateFibonacci = define(t.list(t.int), 'Generate the Fibonacci sequence up to {{n}}.')
compiledGenerateFibonacci = generateFibonacci.compile([{ "input": { "n": 5 }, "output": [0, 1, 1, 2, 3] }])
log(13, generateFibonacci.recompilation_count)
findGreatestCommonDivisor = define(t.int, 'Find the greatest common divisor of {{a}} and {{b}}.')
compiledFindGreatestCommonDivisor = findGreatestCommonDivisor.compile([{ "input": { "a": 12, "b": 18 }, "output": 6 }])
log(14, findGreatestCommonDivisor.recompilation_count)
convertDecimalToBinary = define(t.str, 'Convert the decimal number {{n}} to binary.')
compiledConvertDecimalToBinary = convertDecimalToBinary.compile([{ "input": { "n": 5 }, "output": '101' }])
log(15, convertDecimalToBinary.recompilation_count)
convertBinaryToDecimal = define(t.int, 'Convert the binary number {{n}} to decimal.')
compiledConvertBinaryToDecimal = convertBinaryToDecimal.compile([{ "input": { "n": '101' }, "output": 5 }])
log(16, convertBinaryToDecimal.recompilation_count)
isValidEmail = define(t.bool, 'Check if {{s}} is a valid email address.')
compiledIsValidEmail = isValidEmail.compile([{ "input": { "s": 'xxx@xxx.xxx' }, "output": True }])
isValidUrl = define(t.bool, 'Check if {{s}} is a valid URL.')
compiledIsValidUrl = isValidUrl.compile([{ "input": { "s": 'https://www.xxx.xxx' }, "output": True }])
log(18, 10)
isValidPassword = define(t.bool, 'Check if {{s}} is a valid password.')
compiledIsValidPassword = isValidPassword.compile([{ "input": { "s": 'Abcd!234' }, "output": True }])
log(19, isValidPassword.recompilation_count)
convertJsonToString = define(t.str, 'Convert the JSON object {{o}} into a string.')
#compiledConvertJsonToString = convertJsonToString.compile([{ "input": { "o": { "a": 1, "b": 2 } }, "output": '{"a":1,"b":2}' }])
log(20, 10)
# convertStringToJson = define(t.dict, 'Convert the string {{s}} into a JSON object.')
#compiledConvertStringToJson = convertStringToJson.compile([{ "input": { "s": '{"a":1,"b":2}' }, "output": { "a": 1, "b": 2 } }])
log(21, 10)
#formatDate = define(t.str, 'Format the date {{d}} into a specific string format.')
#compiledFormatDate = formatDate.compile([{ "input": { "d": datetime(2021, 1, 1) }, "output": '2021-02-01' }])
#log(22, formatDate.recompilation_count)
findDateDifference = define(t.int, 'Find the difference between the dates {{d1}} and {{d2}}.')
#compiledFindDateDifference = findDateDifference.compile([{ "input": { "d1": datetime(2021, 1, 1), "d2": datetime(2021, 1, 2) }, "output": 1 }])
log(23, 10)
isAlphanumeric = define(t.bool, 'Check if {{s}} contains only alphanumeric characters.')
compiledIsAlphanumeric = isAlphanumeric.compile([{ "input": { "s": 'abc123' }, "output": True }])
log(24, isAlphanumeric.recompilation_count)
countVowels = define(t.int, 'Count the number of vowels in {{s}}.')
compiledCountVowels = countVowels.compile([{ "input": { "s": 'abc' }, "output": 1 }])
log(25, countVowels.recompilation_count)
removeDuplicates = define(t.list(t.int), 'Remove duplicates from {{xs}}.')
compiledRemoveDuplicates = removeDuplicates.compile([{ "input": { "xs": [1, 2, 3, 1, 2, 3] }, "output": [1, 2, 3] }])
log(26, removeDuplicates.recompilation_count)
isAnagram = define(t.bool, 'Check if {{s1}} and {{s2}} are anagrams.')
compiledIsAnagram = isAnagram.compile([{ "input": { "s1": 'abc', "s2": 'cba' }, "output": True }])
log(27, isAnagram.recompilation_count)
findLongestWord = define(t.str, 'Find the longest word in {{s}}.')
compiledFindLongestWord = findLongestWord.compile([{ "input": { "s": 'abcd efg' }, "output": 'abcd' }])
log(28, findLongestWord.recompilation_count)
capitalizeWords = define(t.str, 'Capitalize the first letter of each word in {{s}}.')
compiledCapitalizeWords = capitalizeWords.compile([{ "input": { "s": 'abc def' }, "output": 'Abc Def' }])
log(29, capitalizeWords.recompilation_count)
findNthFibonacciNumber = define(t.int, 'Find the {{n}}-th Fibonacci number.')   
compiledFindNthFibonacciNumber = findNthFibonacciNumber.compile([{ "input": { "n": 5 }, "output": 5 }])
log(30, findNthFibonacciNumber.recompilation_count)
findPrimeNumbersUpTo = define(t.list(t.int), 'Find all prime numbers up to {{n}}.')
compiledFindPrimeNumbersUpTo = findPrimeNumbersUpTo.compile([{ "input": { "n": 5 }, "output": [2, 3, 5] }])
log(31, findPrimeNumbersUpTo.recompilation_count)
isEvenOrOdd = define(t.bool, 'Check if {{n}} is even or odd.')
compiledIsEvenOrOdd = isEvenOrOdd.compile([{ "input": { "n": 5 }, "output": False }])
log(32, isEvenOrOdd.recompilation_count)
findSquareRoot = define(t.float, 'Find the square root of {{n}}.')
compiledFindSquareRoot = findSquareRoot.compile([{ "input": { "n": 5 }, "output": 2.23606797749979 }])
log(33, findSquareRoot.recompilation_count)
calculatePower = define(t.float, 'Calculate the power of {{n}} to {{p}}.')
compiledCalculatePower = calculatePower.compile([{ "input": { "n": 5, "p": 2 }, "output": 25 }])
log(34, calculatePower.recompilation_count)
flattenArray = define(t.list(t.int), 'Flatten the multi-dimensional array {{xs}}.')
compiledFlattenArray = flattenArray.compile([{ "input": { "xs": [[1, 2], [3]] }, "output": [1, 2, 3] }])
log(35, flattenArray.recompilation_count)
isValidIpAddress = define(t.bool, 'Check if {{s}} is a valid IP address.')
compiledIsValidIpAddress = isValidIpAddress.compile([{ "input": { "s": '192.168.1.1' }, "output": True }])
log(36, isValidIpAddress.recompilation_count)
isLeapYear = define(t.bool, 'Check if {{y}} is a leap year.')
compiledIsLeapYear = isLeapYear.compile([{ "input": { "y": 2020 }, "output": True }])
log(37, isLeapYear.recompilation_count)
findIntersection = define(t.list(t.int), 'Find the intersection of {{xs}} and {{ys}}.')
compiledFindIntersection = findIntersection.compile([{ "input": { "xs": [1, 2, 3], "ys": [2, 3, 4] }, "output": [2, 3] }])
log(28, findIntersection.recompilation_count)
findUnion = define(t.list(t.int), 'Find the union of {{xs}} and {{ys}}.')
compiledFindUnion = findUnion.compile([{ "input": { "xs": [1, 2, 3], "ys": [2, 3, 4] }, "output": [1, 2, 3, 4] }])
log(39, findUnion.recompilation_count)
findDifference = define(t.list(t.str), 'Find the difference between {{xs}} and {{ys}}.')
compiledFindDifference = findDifference.compile([{ "input": { "xs": ['a', 'b', 'c'], "ys": ['b', 'c', 'd'] }, "output": ['a'] }])
log(40, findDifference.recompilation_count)
countWords = define(t.int, 'Count the number of words in {{s}}.')
compiledCountWords = countWords.compile([{ "input": { "s": 'abc def' }, "output": 2 }])
log(41, countWords.recompilation_count)
findMostFrequentWord = define(t.str, 'Find the most frequently occurring word in {{s}}.')
compiledFindMostFrequentWord = findMostFrequentWord.compile([{ "input": { "s": 'abc def abc' }, "output": 'abc' }])
log(42, findMostFrequentWord.recompilation_count)
findDistanceBetweenTwoPoints = define(t.float, 'Find the distance between the points {{p1}} and {{p2}}.')
compiledFindDistanceBetweenTwoPoints = findDistanceBetweenTwoPoints.compile([{ "input": { "p1": [1, 2], "p2": [3, 4] }, "output": 2.8284271247461903 }])
log(43, findDistanceBetweenTwoPoints.recompilation_count)
findAreaOfTriangle = define(t.float, 'Find the area of a triangle given its three sides {{s1}}, {{s2}}, and {{s3}}.')
compiledFindAreaOfTriangle = findAreaOfTriangle.compile([{ "input": { "s1": 3, "s2": 4, "s3": 5 }, "output": 6 }])
log(44, findAreaOfTriangle.recompilation_count)
containsSubstring = define(t.bool, 'Check if {{s}} contains the substring {{sub}}.')
compiledContainsSubstring = containsSubstring.compile([{ "input": { "s": 'abc', "sub": 'ab' }, "output": True }])
log(45, containsSubstring.recompilation_count)
caesarCipher = define(t.str, 'Implement a basic Caesar cipher on {{s}} with a shift of {{shift}}.')
compiledCaesarCipher = caesarCipher.compile([{ "input": { "s": 'abc', "shift": 1 }, "output": 'bcd' }])
log(46, caesarCipher.recompilation_count)
isWithinRange = define(t.bool, 'Check if {{n}} is within the range {{min}} to {{max}}.')
compiledIsWithinRange = isWithinRange.compile([{ "input": { "n": 5, "min": 1, "max": 10 }, "output": True }])
log(47, isWithinRange.recompilation_count)
formatCurrency = define(t.str, 'Format the number {{n}} as a currency.')
compiledFormatCurrency = formatCurrency.compile([{ "input": { "n": 5 }, "output": '$5.00' }])
log(48, formatCurrency.recompilation_count)
findMode = define(t.int, 'Find the mode of the array {{ns}}.')
compiledFindMode = findMode.compile([{ "input": { "ns": [1, 2, 3, 1, 2, 3] }, "output": 1 }])
log(49, findMode.recompilation_count)
isSortedAscending = define(t.bool, 'Check if the array {{ns}} is sorted in ascending order.')
log(50, isSortedAscending.recompilation_count)
